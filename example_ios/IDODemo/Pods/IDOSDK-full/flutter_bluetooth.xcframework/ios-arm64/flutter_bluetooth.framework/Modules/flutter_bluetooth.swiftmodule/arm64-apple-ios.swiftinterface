// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 5.7.2 (swiftlang-5.7.2.135.5 clang-1400.0.29.51)
// swift-module-flags: -target arm64-apple-ios11.0 -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -O -module-name flutter_bluetooth
// swift-module-flags-ignorable: -enable-bare-slash-regex
import Compression
import CoreBluetooth
import CoreFoundation
import Flutter
import Foundation
import LocalAuthentication
import Security
import Swift
import UIKit
import _Concurrency
import _StringProcessing
@_exported import flutter_bluetooth
public let defaultReadChunkSize: Swift.UInt32
public let defaultWriteChunkSize: Swift.UInt32
public let defaultFilePermissions: Swift.UInt16
public let defaultDirectoryPermissions: Swift.UInt16
public enum CompressionMethod : Swift.UInt16 {
  case none
  case deflate
  public init?(rawValue: Swift.UInt16)
  public typealias RawValue = Swift.UInt16
  public var rawValue: Swift.UInt16 {
    get
  }
}
final public class Archive : Swift.Sequence {
  public enum ArchiveError : Swift.Error {
    case unreadableArchive
    case unwritableArchive
    case invalidEntryPath
    case invalidCompressionMethod
    case invalidStartOfCentralDirectoryOffset
    case missingEndOfCentralDirectoryRecord
    case cancelledOperation
    public static func == (a: flutter_bluetooth.Archive.ArchiveError, b: flutter_bluetooth.Archive.ArchiveError) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public enum AccessMode : Swift.UInt {
    case create
    case read
    case update
    public init?(rawValue: Swift.UInt)
    public typealias RawValue = Swift.UInt
    public var rawValue: Swift.UInt {
      get
    }
  }
  final public let url: Foundation.URL
  final public let accessMode: flutter_bluetooth.Archive.AccessMode
  public init?(url: Foundation.URL, accessMode mode: flutter_bluetooth.Archive.AccessMode, preferredEncoding: Swift.String.Encoding? = nil)
  @objc deinit
  final public func makeIterator() -> Swift.AnyIterator<flutter_bluetooth.Entry>
  final public subscript(path: Swift.String) -> flutter_bluetooth.Entry? {
    get
  }
  public typealias Element = flutter_bluetooth.Entry
  public typealias Iterator = Swift.AnyIterator<flutter_bluetooth.Entry>
}
extension flutter_bluetooth.Archive {
  final public func totalUnitCountForRemoving(_ entry: flutter_bluetooth.Entry) -> Swift.Int64
  final public func totalUnitCountForReading(_ entry: flutter_bluetooth.Entry) -> Swift.Int64
  final public func totalUnitCountForAddingItem(at url: Foundation.URL) -> Swift.Int64
}
extension flutter_bluetooth.Archive {
  final public func extract(_ entry: flutter_bluetooth.Entry, to url: Foundation.URL, bufferSize: Swift.UInt32 = defaultReadChunkSize, progress: Foundation.Progress? = nil) throws -> flutter_bluetooth.CRC32
  final public func extract(_ entry: flutter_bluetooth.Entry, bufferSize: Swift.UInt32 = defaultReadChunkSize, progress: Foundation.Progress? = nil, consumer: (_ data: Foundation.Data) throws -> Swift.Void) throws -> flutter_bluetooth.CRC32
}
extension flutter_bluetooth.Archive {
  final public func addEntry(with path: Swift.String, relativeTo baseURL: Foundation.URL, compressionMethod: flutter_bluetooth.CompressionMethod = .none, bufferSize: Swift.UInt32 = defaultWriteChunkSize, progress: Foundation.Progress? = nil) throws
  final public func addEntry(with path: Swift.String, type: flutter_bluetooth.Entry.EntryType, uncompressedSize: Swift.UInt32, modificationDate: Foundation.Date = Date(), permissions: Swift.UInt16? = nil, compressionMethod: flutter_bluetooth.CompressionMethod = .none, bufferSize: Swift.UInt32 = defaultWriteChunkSize, progress: Foundation.Progress? = nil, provider: (_ position: Swift.Int, _ size: Swift.Int) throws -> Foundation.Data) throws
  final public func remove(_ entry: flutter_bluetooth.Entry, bufferSize: Swift.UInt32 = defaultReadChunkSize, progress: Foundation.Progress? = nil) throws
}
public protocol DataConvertible {
  static func + (lhs: Foundation.Data, rhs: Self) -> Foundation.Data
  static func += (lhs: inout Foundation.Data, rhs: Self)
}
extension flutter_bluetooth.DataConvertible {
  public static func + (lhs: Foundation.Data, rhs: Self) -> Foundation.Data
  public static func += (lhs: inout Foundation.Data, rhs: Self)
}
extension Swift.UInt8 : flutter_bluetooth.DataConvertible {
}
extension Swift.UInt16 : flutter_bluetooth.DataConvertible {
}
extension Swift.UInt32 : flutter_bluetooth.DataConvertible {
}
extension Swift.Int : flutter_bluetooth.DataConvertible {
}
extension Swift.Float : flutter_bluetooth.DataConvertible {
}
extension Swift.Double : flutter_bluetooth.DataConvertible {
}
extension Swift.String : flutter_bluetooth.DataConvertible {
  public static func + (lhs: Foundation.Data, rhs: Swift.String) -> Foundation.Data
}
extension Foundation.Data : flutter_bluetooth.DataConvertible {
  public static func + (lhs: Foundation.Data, rhs: Foundation.Data) -> Foundation.Data
}
public typealias CRC32 = Swift.UInt32
public typealias Consumer = (_ data: Foundation.Data) throws -> Swift.Void
public typealias Provider = (_ position: Swift.Int, _ size: Swift.Int) throws -> Foundation.Data
public let crcTable: [Swift.UInt32]
extension Foundation.Data {
  public func crc32(checksum: flutter_bluetooth.CRC32) -> flutter_bluetooth.CRC32
}
@objc public enum DFUFirmwareType : Swift.UInt8 {
  case softdevice = 1
  case bootloader = 2
  case application = 4
  case softdeviceBootloader = 3
  case softdeviceBootloaderApplication = 7
  public init?(rawValue: Swift.UInt8)
  public typealias RawValue = Swift.UInt8
  public var rawValue: Swift.UInt8 {
    get
  }
}
@objc public class DFUFirmware : ObjectiveC.NSObject {
  @objc final public let fileName: Swift.String?
  @objc final public let fileUrl: Foundation.URL?
  @objc public var valid: Swift.Bool {
    @objc get
  }
  @objc public var size: flutter_bluetooth.DFUFirmwareSize {
    @objc get
  }
  @objc public var parts: Swift.Int {
    @objc get
  }
  @objc convenience public init?(urlToZipFile: Foundation.URL)
  @objc public init?(urlToZipFile: Foundation.URL, type: flutter_bluetooth.DFUFirmwareType)
  @objc convenience public init?(zipFile: Foundation.Data)
  @objc public init?(zipFile: Foundation.Data, type: flutter_bluetooth.DFUFirmwareType)
  @objc public init?(urlToBinOrHexFile: Foundation.URL, urlToDatFile: Foundation.URL?, type: flutter_bluetooth.DFUFirmwareType)
  @objc public init?(binFile: Foundation.Data, datFile: Foundation.Data?, type: flutter_bluetooth.DFUFirmwareType)
  @objc public init?(hexFile: Foundation.Data, datFile: Foundation.Data?, type: flutter_bluetooth.DFUFirmwareType)
  @objc deinit
}
@_inheritsConvenienceInitializers @objc open class DFUPeripheralSelector : ObjectiveC.NSObject, flutter_bluetooth.DFUPeripheralSelectorDelegate {
  @objc open func select(_ peripheral: CoreBluetooth.CBPeripheral, advertisementData: [Swift.String : Swift.AnyObject], RSSI: Foundation.NSNumber, hint name: Swift.String? = nil) -> Swift.Bool
  @objc open func filterBy(hint dfuServiceUUID: CoreBluetooth.CBUUID) -> [CoreBluetooth.CBUUID]?
  @objc override dynamic public init()
  @objc deinit
}
@objc public protocol DFUPeripheralSelectorDelegate {
  @objc func select(_ peripheral: CoreBluetooth.CBPeripheral, advertisementData: [Swift.String : Swift.AnyObject], RSSI: Foundation.NSNumber, hint name: Swift.String?) -> Swift.Bool
  @objc func filterBy(hint dfuServiceUUID: CoreBluetooth.CBUUID) -> [CoreBluetooth.CBUUID]?
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers @objc public class DFUServiceController : ObjectiveC.NSObject {
  @objc public func pause()
  @objc public func resume()
  @objc public func abort() -> Swift.Bool
  @objc public func restart()
  @objc public var paused: Swift.Bool {
    @objc get
  }
  @objc public var aborted: Swift.Bool {
    @objc get
  }
  @objc deinit
}
@objc public enum DFUError : Swift.Int {
  case remoteLegacyDFUSuccess = 1
  case remoteLegacyDFUInvalidState = 2
  case remoteLegacyDFUNotSupported = 3
  case remoteLegacyDFUDataExceedsLimit = 4
  case remoteLegacyDFUCrcError = 5
  case remoteLegacyDFUOperationFailed = 6
  case remoteSecureDFUSuccess = 11
  case remoteSecureDFUOpCodeNotSupported = 12
  case remoteSecureDFUInvalidParameter = 13
  case remoteSecureDFUInsufficientResources = 14
  case remoteSecureDFUInvalidObject = 15
  case remoteSecureDFUSignatureMismatch = 16
  case remoteSecureDFUUnsupportedType = 17
  case remoteSecureDFUOperationNotpermitted = 18
  case remoteSecureDFUOperationFailed = 20
  case remoteSecureDFUExtendedError = 21
  case remoteExperimentalButtonlessDFUSuccess = 9001
  case remoteExperimentalButtonlessDFUOpCodeNotSupported = 9002
  case remoteExperimentalButtonlessDFUOperationFailed = 9004
  case remoteButtonlessDFUSuccess = 31
  case remoteButtonlessDFUOpCodeNotSupported = 32
  case remoteButtonlessDFUOperationFailed = 34
  case fileNotSpecified = 101
  case fileInvalid = 102
  case extendedInitPacketRequired = 103
  case initPacketRequired = 104
  case failedToConnect = 201
  case deviceDisconnected = 202
  case bluetoothDisabled = 203
  case serviceDiscoveryFailed = 301
  case deviceNotSupported = 302
  case readingVersionFailed = 303
  case enablingControlPointFailed = 304
  case writingCharacteristicFailed = 305
  case receivingNotificationFailed = 306
  case unsupportedResponse = 307
  case bytesLost = 308
  case crcError = 309
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
@objc public enum DFUState : Swift.Int {
  case connecting
  case starting
  case enablingDfuMode
  case uploading
  case validating
  case disconnecting
  case completed
  case aborted
  public func description() -> Swift.String
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
@objc public protocol DFUProgressDelegate {
  @objc func dfuProgressDidChange(for part: Swift.Int, outOf totalParts: Swift.Int, to progress: Swift.Int, currentSpeedBytesPerSecond: Swift.Double, avgSpeedBytesPerSecond: Swift.Double)
}
@objc public protocol DFUServiceDelegate {
  @objc func dfuStateDidChange(to state: flutter_bluetooth.DFUState)
  @objc func dfuError(_ error: flutter_bluetooth.DFUError, didOccurWithMessage message: Swift.String)
}
@objc public class DFUServiceInitiator : ObjectiveC.NSObject {
  @objc weak public var delegate: flutter_bluetooth.DFUServiceDelegate?
  @objc weak public var progressDelegate: flutter_bluetooth.DFUProgressDelegate?
  @objc weak public var logger: flutter_bluetooth.LoggerDelegate?
  @objc public var peripheralSelector: flutter_bluetooth.DFUPeripheralSelectorDelegate
  @objc public var packetReceiptNotificationParameter: Swift.UInt16
  @objc public var forceDfu: Swift.Bool
  @objc public var alternativeAdvertisingNameEnabled: Swift.Bool
  @objc public var enableUnsafeExperimentalButtonlessServiceInSecureDfu: Swift.Bool
  @objc public init(centralManager: CoreBluetooth.CBCentralManager, target: CoreBluetooth.CBPeripheral)
  @objc public func with(firmware file: flutter_bluetooth.DFUFirmware) -> flutter_bluetooth.DFUServiceInitiator
  @objc public func start() -> flutter_bluetooth.DFUServiceController?
  @objc deinit
}
@_hasMissingDesignatedInitializers @objc open class DFUFirmwareSize : ObjectiveC.NSObject {
  open var softdevice: Swift.UInt32 {
    get
  }
  open var bootloader: Swift.UInt32 {
    get
  }
  open var application: Swift.UInt32 {
    get
  }
  @objc deinit
}
public struct Entry : Swift.Equatable {
  public enum EntryType : Swift.Int {
    case file
    case directory
    case symlink
    public init?(rawValue: Swift.Int)
    public typealias RawValue = Swift.Int
    public var rawValue: Swift.Int {
      get
    }
  }
  public func path(using encoding: Swift.String.Encoding) -> Swift.String
  public var path: Swift.String {
    get
  }
  public var fileAttributes: [Foundation.FileAttributeKey : Any] {
    get
  }
  public var checksum: flutter_bluetooth.CRC32 {
    get
  }
  public var type: flutter_bluetooth.Entry.EntryType {
    get
  }
  public var compressedSize: Swift.Int {
    get
  }
  public var uncompressedSize: Swift.Int {
    get
  }
  public static func == (lhs: flutter_bluetooth.Entry, rhs: flutter_bluetooth.Entry) -> Swift.Bool
}
extension Foundation.FileManager {
  public func zipItem(at sourceURL: Foundation.URL, to destinationURL: Foundation.URL, shouldKeepParent: Swift.Bool = true, compressionMethod: flutter_bluetooth.CompressionMethod = .none, progress: Foundation.Progress? = nil) throws
  public func unzipItem(at sourceURL: Foundation.URL, to destinationURL: Foundation.URL, progress: Foundation.Progress? = nil, preferredEncoding: Swift.String.Encoding? = nil) throws
}
extension Foundation.URL {
  public func isContained(in parentDirectoryURL: Foundation.URL) -> Swift.Bool
}
@objc @_inheritsConvenienceInitializers public class IntelHex2BinConverter : ObjectiveC.NSObject {
  public static func convert(_ hex: Foundation.Data, mbrSize: Swift.UInt32 = 0) -> Foundation.Data?
  @objc override dynamic public init()
  @objc deinit
}
public protocol SSCoadble : Swift.Decodable, Swift.Encodable {
  func toDict() -> Swift.Dictionary<Swift.String, Any>?
  func toData() -> Foundation.Data?
  func toString() -> Swift.String?
}
extension flutter_bluetooth.SSCoadble {
  public func toData() -> Foundation.Data?
  public func toDict() -> Swift.Dictionary<Swift.String, Any>?
  public func toString() -> Swift.String?
}
public let KeychainAccessErrorDomain: Swift.String
public enum ItemClass {
  case genericPassword
  case internetPassword
}
public enum ProtocolType {
  case ftp
  case ftpAccount
  case http
  case irc
  case nntp
  case pop3
  case smtp
  case socks
  case imap
  case ldap
  case appleTalk
  case afp
  case telnet
  case ssh
  case ftps
  case https
  case httpProxy
  case httpsProxy
  case ftpProxy
  case smb
  case rtsp
  case rtspProxy
  case daap
  case eppc
  case ipp
  case nntps
  case ldaps
  case telnetS
  case imaps
  case ircs
  case pop3S
}
public enum AuthenticationType {
  case ntlm
  case msn
  case dpa
  case rpa
  case httpBasic
  case httpDigest
  case htmlForm
  case `default`
}
public enum Accessibility {
  case whenUnlocked
  case afterFirstUnlock
  @available(macCatalyst, unavailable)
  case always
  @available(iOS 8.0, macOS 10.10, *)
  case whenPasscodeSetThisDeviceOnly
  case whenUnlockedThisDeviceOnly
  case afterFirstUnlockThisDeviceOnly
  @available(macCatalyst, unavailable)
  case alwaysThisDeviceOnly
}
public enum AuthenticationUI {
  case allow
  case fail
  case skip
  public static func == (a: flutter_bluetooth.AuthenticationUI, b: flutter_bluetooth.AuthenticationUI) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@available(iOS 9.0, macOS 10.11, *)
extension flutter_bluetooth.AuthenticationUI {
  public var rawValue: Swift.String {
    get
  }
  public var description: Swift.String {
    get
  }
}
public struct AuthenticationPolicy : Swift.OptionSet {
  @available(iOS 8.0, macOS 10.10, watchOS 2.0, tvOS 8.0, *)
  public static let userPresence: flutter_bluetooth.AuthenticationPolicy
  @available(iOS 11.3, macOS 10.13.4, watchOS 4.3, tvOS 11.3, *)
  public static let biometryAny: flutter_bluetooth.AuthenticationPolicy
  @available(iOS, introduced: 9.0, deprecated: 11.3, renamed: "biometryAny")
  @available(macOS, introduced: 10.12.1, deprecated: 10.13.4, renamed: "biometryAny")
  @available(watchOS, introduced: 2.0, deprecated: 4.3, renamed: "biometryAny")
  @available(tvOS, introduced: 9.0, deprecated: 11.3, renamed: "biometryAny")
  public static let touchIDAny: flutter_bluetooth.AuthenticationPolicy
  @available(iOS 11.3, macOS 10.13, watchOS 4.3, tvOS 11.3, *)
  public static let biometryCurrentSet: flutter_bluetooth.AuthenticationPolicy
  @available(iOS, introduced: 9.0, deprecated: 11.3, renamed: "biometryCurrentSet")
  @available(macOS, introduced: 10.12.1, deprecated: 10.13.4, renamed: "biometryCurrentSet")
  @available(watchOS, introduced: 2.0, deprecated: 4.3, renamed: "biometryCurrentSet")
  @available(tvOS, introduced: 9.0, deprecated: 11.3, renamed: "biometryCurrentSet")
  public static let touchIDCurrentSet: flutter_bluetooth.AuthenticationPolicy
  @available(iOS 9.0, macOS 10.11, watchOS 2.0, tvOS 9.0, *)
  public static let devicePasscode: flutter_bluetooth.AuthenticationPolicy
  @available(macOS 10.15, *)
  @available(iOS, unavailable)
  @available(watchOS, unavailable)
  @available(tvOS, unavailable)
  public static let watch: flutter_bluetooth.AuthenticationPolicy
  @available(iOS 9.0, macOS 10.12.1, watchOS 2.0, tvOS 9.0, *)
  public static let or: flutter_bluetooth.AuthenticationPolicy
  @available(iOS 9.0, macOS 10.12.1, watchOS 2.0, tvOS 9.0, *)
  public static let and: flutter_bluetooth.AuthenticationPolicy
  @available(iOS 9.0, macOS 10.12.1, watchOS 2.0, tvOS 9.0, *)
  public static let privateKeyUsage: flutter_bluetooth.AuthenticationPolicy
  @available(iOS 9.0, macOS 10.12.1, watchOS 2.0, tvOS 9.0, *)
  public static let applicationPassword: flutter_bluetooth.AuthenticationPolicy
  public let rawValue: Swift.UInt
  public init(rawValue: Swift.UInt)
  public typealias ArrayLiteralElement = flutter_bluetooth.AuthenticationPolicy
  public typealias Element = flutter_bluetooth.AuthenticationPolicy
  public typealias RawValue = Swift.UInt
}
public struct Attributes {
  public var `class`: Swift.String? {
    get
  }
  public var data: Foundation.Data? {
    get
  }
  public var ref: Foundation.Data? {
    get
  }
  public var persistentRef: Foundation.Data? {
    get
  }
  public var accessible: Swift.String? {
    get
  }
  public var accessControl: Security.SecAccessControl? {
    get
  }
  public var accessGroup: Swift.String? {
    get
  }
  public var synchronizable: Swift.Bool? {
    get
  }
  public var creationDate: Foundation.Date? {
    get
  }
  public var modificationDate: Foundation.Date? {
    get
  }
  public var attributeDescription: Swift.String? {
    get
  }
  public var comment: Swift.String? {
    get
  }
  public var creator: Swift.String? {
    get
  }
  public var type: Swift.String? {
    get
  }
  public var label: Swift.String? {
    get
  }
  public var isInvisible: Swift.Bool? {
    get
  }
  public var isNegative: Swift.Bool? {
    get
  }
  public var account: Swift.String? {
    get
  }
  public var service: Swift.String? {
    get
  }
  public var generic: Foundation.Data? {
    get
  }
  public var securityDomain: Swift.String? {
    get
  }
  public var server: Swift.String? {
    get
  }
  public var `protocol`: Swift.String? {
    get
  }
  public var authenticationType: Swift.String? {
    get
  }
  public var port: Swift.Int? {
    get
  }
  public var path: Swift.String? {
    get
  }
  public subscript(key: Swift.String) -> Any? {
    get
  }
}
@_hasMissingDesignatedInitializers final public class Keychain {
  final public var itemClass: flutter_bluetooth.ItemClass {
    get
  }
  final public var service: Swift.String {
    get
  }
  final public var accessGroup: Swift.String? {
    get
  }
  final public var server: Foundation.URL {
    get
  }
  final public var protocolType: flutter_bluetooth.ProtocolType {
    get
  }
  final public var authenticationType: flutter_bluetooth.AuthenticationType {
    get
  }
  final public var accessibility: flutter_bluetooth.Accessibility {
    get
  }
  @available(iOS 8.0, macOS 10.10, *)
  @available(watchOS, unavailable)
  final public var authenticationPolicy: flutter_bluetooth.AuthenticationPolicy? {
    get
  }
  final public var synchronizable: Swift.Bool {
    get
  }
  final public var label: Swift.String? {
    get
  }
  final public var comment: Swift.String? {
    get
  }
  @available(iOS 8.0, macOS 10.10, *)
  @available(watchOS, unavailable)
  final public var authenticationPrompt: Swift.String? {
    get
  }
  @available(iOS 9.0, macOS 10.11, *)
  final public var authenticationUI: flutter_bluetooth.AuthenticationUI {
    get
  }
  @available(iOS 9.0, macOS 10.11, *)
  final public var authenticationContext: LocalAuthentication.LAContext? {
    get
  }
  convenience public init()
  convenience public init(service: Swift.String)
  convenience public init(accessGroup: Swift.String)
  convenience public init(service: Swift.String, accessGroup: Swift.String)
  convenience public init(server: Swift.String, protocolType: flutter_bluetooth.ProtocolType, accessGroup: Swift.String? = nil, authenticationType: flutter_bluetooth.AuthenticationType = .default)
  convenience public init(server: Foundation.URL, protocolType: flutter_bluetooth.ProtocolType, accessGroup: Swift.String? = nil, authenticationType: flutter_bluetooth.AuthenticationType = .default)
  final public func accessibility(_ accessibility: flutter_bluetooth.Accessibility) -> flutter_bluetooth.Keychain
  @available(iOS 8.0, macOS 10.10, *)
  @available(watchOS, unavailable)
  final public func accessibility(_ accessibility: flutter_bluetooth.Accessibility, authenticationPolicy: flutter_bluetooth.AuthenticationPolicy) -> flutter_bluetooth.Keychain
  final public func synchronizable(_ synchronizable: Swift.Bool) -> flutter_bluetooth.Keychain
  final public func label(_ label: Swift.String) -> flutter_bluetooth.Keychain
  final public func comment(_ comment: Swift.String) -> flutter_bluetooth.Keychain
  final public func attributes(_ attributes: [Swift.String : Any]) -> flutter_bluetooth.Keychain
  @available(iOS 8.0, macOS 10.10, *)
  @available(watchOS, unavailable)
  final public func authenticationPrompt(_ authenticationPrompt: Swift.String) -> flutter_bluetooth.Keychain
  @available(iOS 9.0, macOS 10.11, *)
  final public func authenticationUI(_ authenticationUI: flutter_bluetooth.AuthenticationUI) -> flutter_bluetooth.Keychain
  @available(iOS 9.0, macOS 10.11, *)
  final public func authenticationContext(_ authenticationContext: LocalAuthentication.LAContext) -> flutter_bluetooth.Keychain
  final public func get(_ key: Swift.String, ignoringAttributeSynchronizable: Swift.Bool = true) throws -> Swift.String?
  final public func getString(_ key: Swift.String, ignoringAttributeSynchronizable: Swift.Bool = true) throws -> Swift.String?
  final public func getData(_ key: Swift.String, ignoringAttributeSynchronizable: Swift.Bool = true) throws -> Foundation.Data?
  final public func get<T>(_ key: Swift.String, ignoringAttributeSynchronizable: Swift.Bool = true, handler: (flutter_bluetooth.Attributes?) -> T) throws -> T
  final public func set(_ value: Swift.String, key: Swift.String, ignoringAttributeSynchronizable: Swift.Bool = true) throws
  final public func set(_ value: Foundation.Data, key: Swift.String, ignoringAttributeSynchronizable: Swift.Bool = true) throws
  final public subscript(key: Swift.String) -> Swift.String? {
    get
    set
  }
  final public subscript(string key: Swift.String) -> Swift.String? {
    get
    set
  }
  final public subscript(data key: Swift.String) -> Foundation.Data? {
    get
    set
  }
  final public subscript(attributes key: Swift.String) -> flutter_bluetooth.Attributes? {
    get
  }
  final public func remove(_ key: Swift.String, ignoringAttributeSynchronizable: Swift.Bool = true) throws
  final public func removeAll() throws
  final public func contains(_ key: Swift.String, withoutAuthenticationUI: Swift.Bool = false) throws -> Swift.Bool
  final public class func allKeys(_ itemClass: flutter_bluetooth.ItemClass) -> [(Swift.String, Swift.String)]
  final public func allKeys() -> [Swift.String]
  final public class func allItems(_ itemClass: flutter_bluetooth.ItemClass) -> [[Swift.String : Any]]
  final public func allItems() -> [[Swift.String : Any]]
  @available(iOS 8.0, *)
  final public func getSharedPassword(_ completion: @escaping (_ account: Swift.String?, _ password: Swift.String?, _ error: Swift.Error?) -> () = { account, password, error -> () in })
  @available(iOS 8.0, *)
  final public func getSharedPassword(_ account: Swift.String, completion: @escaping (_ password: Swift.String?, _ error: Swift.Error?) -> () = { password, error -> () in })
  @available(iOS 8.0, *)
  final public func setSharedPassword(_ password: Swift.String, account: Swift.String, completion: @escaping (_ error: Swift.Error?) -> () = { e -> () in })
  @available(iOS 8.0, *)
  final public func removeSharedPassword(_ account: Swift.String, completion: @escaping (_ error: Swift.Error?) -> () = { e -> () in })
  @available(iOS 8.0, *)
  final public class func requestSharedWebCredential(_ completion: @escaping (_ credentials: [[Swift.String : Swift.String]], _ error: Swift.Error?) -> () = { credentials, error -> () in })
  @available(iOS 8.0, *)
  final public class func requestSharedWebCredential(domain: Swift.String, completion: @escaping (_ credentials: [[Swift.String : Swift.String]], _ error: Swift.Error?) -> () = { credentials, error -> () in })
  @available(iOS 8.0, *)
  final public class func requestSharedWebCredential(domain: Swift.String, account: Swift.String, completion: @escaping (_ credentials: [[Swift.String : Swift.String]], _ error: Swift.Error?) -> () = { credentials, error -> () in })
  @available(iOS 8.0, *)
  final public class func generatePassword() -> Swift.String
  @objc deinit
}
extension flutter_bluetooth.Keychain : Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible {
  final public var description: Swift.String {
    get
  }
  final public var debugDescription: Swift.String {
    get
  }
}
extension flutter_bluetooth.Attributes : Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible {
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
}
extension flutter_bluetooth.ItemClass : Swift.RawRepresentable, Swift.CustomStringConvertible {
  public init?(rawValue: Swift.String)
  public var rawValue: Swift.String {
    get
  }
  public var description: Swift.String {
    get
  }
  public typealias RawValue = Swift.String
}
extension flutter_bluetooth.ProtocolType : Swift.RawRepresentable, Swift.CustomStringConvertible {
  public init?(rawValue: Swift.String)
  public var rawValue: Swift.String {
    get
  }
  public var description: Swift.String {
    get
  }
  public typealias RawValue = Swift.String
}
extension flutter_bluetooth.AuthenticationType : Swift.RawRepresentable, Swift.CustomStringConvertible {
  public init?(rawValue: Swift.String)
  public var rawValue: Swift.String {
    get
  }
  public var description: Swift.String {
    get
  }
  public typealias RawValue = Swift.String
}
extension flutter_bluetooth.Accessibility : Swift.RawRepresentable, Swift.CustomStringConvertible {
  public init?(rawValue: Swift.String)
  public var rawValue: Swift.String {
    get
  }
  public var description: Swift.String {
    get
  }
  public typealias RawValue = Swift.String
}
public enum Status : Darwin.OSStatus, Swift.Error {
  case success
  case unimplemented
  case diskFull
  case io
  case opWr
  case param
  case wrPerm
  case allocate
  case userCanceled
  case badReq
  case internalComponent
  case notAvailable
  case readOnly
  case authFailed
  case noSuchKeychain
  case invalidKeychain
  case duplicateKeychain
  case duplicateCallback
  case invalidCallback
  case duplicateItem
  case itemNotFound
  case bufferTooSmall
  case dataTooLarge
  case noSuchAttr
  case invalidItemRef
  case invalidSearchRef
  case noSuchClass
  case noDefaultKeychain
  case interactionNotAllowed
  case readOnlyAttr
  case wrongSecVersion
  case keySizeNotAllowed
  case noStorageModule
  case noCertificateModule
  case noPolicyModule
  case interactionRequired
  case dataNotAvailable
  case dataNotModifiable
  case createChainFailed
  case invalidPrefsDomain
  case inDarkWake
  case aclNotSimple
  case policyNotFound
  case invalidTrustSetting
  case noAccessForItem
  case invalidOwnerEdit
  case trustNotAvailable
  case unsupportedFormat
  case unknownFormat
  case keyIsSensitive
  case multiplePrivKeys
  case passphraseRequired
  case invalidPasswordRef
  case invalidTrustSettings
  case noTrustSettings
  case pkcs12VerifyFailure
  case invalidCertificate
  case notSigner
  case policyDenied
  case invalidKey
  case decode
  case `internal`
  case unsupportedAlgorithm
  case unsupportedOperation
  case unsupportedPadding
  case itemInvalidKey
  case itemInvalidKeyType
  case itemInvalidValue
  case itemClassMissing
  case itemMatchUnsupported
  case useItemListUnsupported
  case useKeychainUnsupported
  case useKeychainListUnsupported
  case returnDataUnsupported
  case returnAttributesUnsupported
  case returnRefUnsupported
  case returnPersitentRefUnsupported
  case valueRefUnsupported
  case valuePersistentRefUnsupported
  case returnMissingPointer
  case matchLimitUnsupported
  case itemIllegalQuery
  case waitForCallback
  case missingEntitlement
  case upgradePending
  case mpSignatureInvalid
  case otrTooOld
  case otrIDTooNew
  case serviceNotAvailable
  case insufficientClientID
  case deviceReset
  case deviceFailed
  case appleAddAppACLSubject
  case applePublicKeyIncomplete
  case appleSignatureMismatch
  case appleInvalidKeyStartDate
  case appleInvalidKeyEndDate
  case conversionError
  case appleSSLv2Rollback
  case quotaExceeded
  case fileTooBig
  case invalidDatabaseBlob
  case invalidKeyBlob
  case incompatibleDatabaseBlob
  case incompatibleKeyBlob
  case hostNameMismatch
  case unknownCriticalExtensionFlag
  case noBasicConstraints
  case noBasicConstraintsCA
  case invalidAuthorityKeyID
  case invalidSubjectKeyID
  case invalidKeyUsageForPolicy
  case invalidExtendedKeyUsage
  case invalidIDLinkage
  case pathLengthConstraintExceeded
  case invalidRoot
  case crlExpired
  case crlNotValidYet
  case crlNotFound
  case crlServerDown
  case crlBadURI
  case unknownCertExtension
  case unknownCRLExtension
  case crlNotTrusted
  case crlPolicyFailed
  case idpFailure
  case smimeEmailAddressesNotFound
  case smimeBadExtendedKeyUsage
  case smimeBadKeyUsage
  case smimeKeyUsageNotCritical
  case smimeNoEmailAddress
  case smimeSubjAltNameNotCritical
  case sslBadExtendedKeyUsage
  case ocspBadResponse
  case ocspBadRequest
  case ocspUnavailable
  case ocspStatusUnrecognized
  case endOfData
  case incompleteCertRevocationCheck
  case networkFailure
  case ocspNotTrustedToAnchor
  case recordModified
  case ocspSignatureError
  case ocspNoSigner
  case ocspResponderMalformedReq
  case ocspResponderInternalError
  case ocspResponderTryLater
  case ocspResponderSignatureRequired
  case ocspResponderUnauthorized
  case ocspResponseNonceMismatch
  case codeSigningBadCertChainLength
  case codeSigningNoBasicConstraints
  case codeSigningBadPathLengthConstraint
  case codeSigningNoExtendedKeyUsage
  case codeSigningDevelopment
  case resourceSignBadCertChainLength
  case resourceSignBadExtKeyUsage
  case trustSettingDeny
  case invalidSubjectName
  case unknownQualifiedCertStatement
  case mobileMeRequestQueued
  case mobileMeRequestRedirected
  case mobileMeServerError
  case mobileMeServerNotAvailable
  case mobileMeServerAlreadyExists
  case mobileMeServerServiceErr
  case mobileMeRequestAlreadyPending
  case mobileMeNoRequestPending
  case mobileMeCSRVerifyFailure
  case mobileMeFailedConsistencyCheck
  case notInitialized
  case invalidHandleUsage
  case pvcReferentNotFound
  case functionIntegrityFail
  case internalError
  case memoryError
  case invalidData
  case mdsError
  case invalidPointer
  case selfCheckFailed
  case functionFailed
  case moduleManifestVerifyFailed
  case invalidGUID
  case invalidHandle
  case invalidDBList
  case invalidPassthroughID
  case invalidNetworkAddress
  case crlAlreadySigned
  case invalidNumberOfFields
  case verificationFailure
  case unknownTag
  case invalidSignature
  case invalidName
  case invalidCertificateRef
  case invalidCertificateGroup
  case tagNotFound
  case invalidQuery
  case invalidValue
  case callbackFailed
  case aclDeleteFailed
  case aclReplaceFailed
  case aclAddFailed
  case aclChangeFailed
  case invalidAccessCredentials
  case invalidRecord
  case invalidACL
  case invalidSampleValue
  case incompatibleVersion
  case privilegeNotGranted
  case invalidScope
  case pvcAlreadyConfigured
  case invalidPVC
  case emmLoadFailed
  case emmUnloadFailed
  case addinLoadFailed
  case invalidKeyRef
  case invalidKeyHierarchy
  case addinUnloadFailed
  case libraryReferenceNotFound
  case invalidAddinFunctionTable
  case invalidServiceMask
  case moduleNotLoaded
  case invalidSubServiceID
  case attributeNotInContext
  case moduleManagerInitializeFailed
  case moduleManagerNotFound
  case eventNotificationCallbackNotFound
  case inputLengthError
  case outputLengthError
  case privilegeNotSupported
  case deviceError
  case attachHandleBusy
  case notLoggedIn
  case algorithmMismatch
  case keyUsageIncorrect
  case keyBlobTypeIncorrect
  case keyHeaderInconsistent
  case unsupportedKeyFormat
  case unsupportedKeySize
  case invalidKeyUsageMask
  case unsupportedKeyUsageMask
  case invalidKeyAttributeMask
  case unsupportedKeyAttributeMask
  case invalidKeyLabel
  case unsupportedKeyLabel
  case invalidKeyFormat
  case unsupportedVectorOfBuffers
  case invalidInputVector
  case invalidOutputVector
  case invalidContext
  case invalidAlgorithm
  case invalidAttributeKey
  case missingAttributeKey
  case invalidAttributeInitVector
  case missingAttributeInitVector
  case invalidAttributeSalt
  case missingAttributeSalt
  case invalidAttributePadding
  case missingAttributePadding
  case invalidAttributeRandom
  case missingAttributeRandom
  case invalidAttributeSeed
  case missingAttributeSeed
  case invalidAttributePassphrase
  case missingAttributePassphrase
  case invalidAttributeKeyLength
  case missingAttributeKeyLength
  case invalidAttributeBlockSize
  case missingAttributeBlockSize
  case invalidAttributeOutputSize
  case missingAttributeOutputSize
  case invalidAttributeRounds
  case missingAttributeRounds
  case invalidAlgorithmParms
  case missingAlgorithmParms
  case invalidAttributeLabel
  case missingAttributeLabel
  case invalidAttributeKeyType
  case missingAttributeKeyType
  case invalidAttributeMode
  case missingAttributeMode
  case invalidAttributeEffectiveBits
  case missingAttributeEffectiveBits
  case invalidAttributeStartDate
  case missingAttributeStartDate
  case invalidAttributeEndDate
  case missingAttributeEndDate
  case invalidAttributeVersion
  case missingAttributeVersion
  case invalidAttributePrime
  case missingAttributePrime
  case invalidAttributeBase
  case missingAttributeBase
  case invalidAttributeSubprime
  case missingAttributeSubprime
  case invalidAttributeIterationCount
  case missingAttributeIterationCount
  case invalidAttributeDLDBHandle
  case missingAttributeDLDBHandle
  case invalidAttributeAccessCredentials
  case missingAttributeAccessCredentials
  case invalidAttributePublicKeyFormat
  case missingAttributePublicKeyFormat
  case invalidAttributePrivateKeyFormat
  case missingAttributePrivateKeyFormat
  case invalidAttributeSymmetricKeyFormat
  case missingAttributeSymmetricKeyFormat
  case invalidAttributeWrappedKeyFormat
  case missingAttributeWrappedKeyFormat
  case stagedOperationInProgress
  case stagedOperationNotStarted
  case verifyFailed
  case querySizeUnknown
  case blockSizeMismatch
  case publicKeyInconsistent
  case deviceVerifyFailed
  case invalidLoginName
  case alreadyLoggedIn
  case invalidDigestAlgorithm
  case invalidCRLGroup
  case certificateCannotOperate
  case certificateExpired
  case certificateNotValidYet
  case certificateRevoked
  case certificateSuspended
  case insufficientCredentials
  case invalidAction
  case invalidAuthority
  case verifyActionFailed
  case invalidCertAuthority
  case invaldCRLAuthority
  case invalidCRLEncoding
  case invalidCRLType
  case invalidCRL
  case invalidFormType
  case invalidID
  case invalidIdentifier
  case invalidIndex
  case invalidPolicyIdentifiers
  case invalidTimeString
  case invalidReason
  case invalidRequestInputs
  case invalidResponseVector
  case invalidStopOnPolicy
  case invalidTuple
  case multipleValuesUnsupported
  case notTrusted
  case noDefaultAuthority
  case rejectedForm
  case requestLost
  case requestRejected
  case unsupportedAddressType
  case unsupportedService
  case invalidTupleGroup
  case invalidBaseACLs
  case invalidTupleCredendtials
  case invalidEncoding
  case invalidValidityPeriod
  case invalidRequestor
  case requestDescriptor
  case invalidBundleInfo
  case invalidCRLIndex
  case noFieldValues
  case unsupportedFieldFormat
  case unsupportedIndexInfo
  case unsupportedLocality
  case unsupportedNumAttributes
  case unsupportedNumIndexes
  case unsupportedNumRecordTypes
  case fieldSpecifiedMultiple
  case incompatibleFieldFormat
  case invalidParsingModule
  case databaseLocked
  case datastoreIsOpen
  case missingValue
  case unsupportedQueryLimits
  case unsupportedNumSelectionPreds
  case unsupportedOperator
  case invalidDBLocation
  case invalidAccessRequest
  case invalidIndexInfo
  case invalidNewOwner
  case invalidModifyMode
  case missingRequiredExtension
  case extendedKeyUsageNotCritical
  case timestampMissing
  case timestampInvalid
  case timestampNotTrusted
  case timestampServiceNotAvailable
  case timestampBadAlg
  case timestampBadRequest
  case timestampBadDataFormat
  case timestampTimeNotAvailable
  case timestampUnacceptedPolicy
  case timestampUnacceptedExtension
  case timestampAddInfoNotAvailable
  case timestampSystemFailure
  case signingTimeMissing
  case timestampRejection
  case timestampWaiting
  case timestampRevocationWarning
  case timestampRevocationNotification
  case unexpectedError
}
extension flutter_bluetooth.Status : Swift.RawRepresentable, Swift.CustomStringConvertible {
  public init(status: Darwin.OSStatus)
  public var description: Swift.String {
    get
  }
  public init?(rawValue: Darwin.OSStatus)
  public typealias RawValue = Darwin.OSStatus
  public var rawValue: Darwin.OSStatus {
    get
  }
}
extension flutter_bluetooth.Status : Foundation.CustomNSError {
  public static let errorDomain: Swift.String
  public var errorCode: Swift.Int {
    get
  }
  public var errorUserInfo: [Swift.String : Any] {
    get
  }
}
@_inheritsConvenienceInitializers @objc public class LegacyDFUServiceInitiator : flutter_bluetooth.DFUServiceInitiator {
  @objc override public func start() -> flutter_bluetooth.DFUServiceController?
  @objc override public init(centralManager: CoreBluetooth.CBCentralManager, target: CoreBluetooth.CBPeripheral)
  @objc deinit
}
@objc public enum LogLevel : Swift.Int {
  case debug = 0
  case verbose = 1
  case info = 5
  case application = 10
  case warning = 15
  case error = 20
  public func name() -> Swift.String
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
@objc public protocol LoggerDelegate {
  @objc func logWith(_ level: flutter_bluetooth.LogLevel, message: Swift.String)
}
@_inheritsConvenienceInitializers @objc public class SecureDFUServiceInitiator : flutter_bluetooth.DFUServiceInitiator {
  @objc override public func start() -> flutter_bluetooth.DFUServiceController?
  @objc override public init(centralManager: CoreBluetooth.CBCentralManager, target: CoreBluetooth.CBPeripheral)
  @objc deinit
}
@objc @_inheritsConvenienceInitializers public class SwiftFlutterBluetoothPlugin : ObjectiveC.NSObject, Flutter.FlutterPlugin {
  @objc public static func register(with registrar: Flutter.FlutterPluginRegistrar)
  @objc public func handle(_ call: Flutter.FlutterMethodCall, result: @escaping Flutter.FlutterResult)
  @objc override dynamic public init()
  @objc deinit
}
extension flutter_bluetooth.SwiftFlutterBluetoothPlugin : Flutter.FlutterStreamHandler {
  @objc dynamic public func onListen(withArguments arguments: Any?, eventSink events: @escaping Flutter.FlutterEventSink) -> Flutter.FlutterError?
  @objc dynamic public func onCancel(withArguments arguments: Any?) -> Flutter.FlutterError?
}
extension flutter_bluetooth.CompressionMethod : Swift.Equatable {}
extension flutter_bluetooth.CompressionMethod : Swift.Hashable {}
extension flutter_bluetooth.CompressionMethod : Swift.RawRepresentable {}
extension flutter_bluetooth.Archive.ArchiveError : Swift.Equatable {}
extension flutter_bluetooth.Archive.ArchiveError : Swift.Hashable {}
extension flutter_bluetooth.Archive.AccessMode : Swift.Equatable {}
extension flutter_bluetooth.Archive.AccessMode : Swift.Hashable {}
extension flutter_bluetooth.Archive.AccessMode : Swift.RawRepresentable {}
extension flutter_bluetooth.DFUFirmwareType : Swift.Equatable {}
extension flutter_bluetooth.DFUFirmwareType : Swift.Hashable {}
extension flutter_bluetooth.DFUFirmwareType : Swift.RawRepresentable {}
extension flutter_bluetooth.DFUError : Swift.Equatable {}
extension flutter_bluetooth.DFUError : Swift.Hashable {}
extension flutter_bluetooth.DFUError : Swift.RawRepresentable {}
extension flutter_bluetooth.DFUState : Swift.Equatable {}
extension flutter_bluetooth.DFUState : Swift.Hashable {}
extension flutter_bluetooth.DFUState : Swift.RawRepresentable {}
extension flutter_bluetooth.Entry.EntryType : Swift.Equatable {}
extension flutter_bluetooth.Entry.EntryType : Swift.Hashable {}
extension flutter_bluetooth.Entry.EntryType : Swift.RawRepresentable {}
extension flutter_bluetooth.ItemClass : Swift.Equatable {}
extension flutter_bluetooth.ItemClass : Swift.Hashable {}
extension flutter_bluetooth.ProtocolType : Swift.Equatable {}
extension flutter_bluetooth.ProtocolType : Swift.Hashable {}
extension flutter_bluetooth.AuthenticationType : Swift.Equatable {}
extension flutter_bluetooth.AuthenticationType : Swift.Hashable {}
extension flutter_bluetooth.Accessibility : Swift.Equatable {}
extension flutter_bluetooth.Accessibility : Swift.Hashable {}
extension flutter_bluetooth.AuthenticationUI : Swift.Equatable {}
extension flutter_bluetooth.AuthenticationUI : Swift.Hashable {}
extension flutter_bluetooth.Status : Swift.Equatable {}
extension flutter_bluetooth.Status : Swift.Hashable {}
extension flutter_bluetooth.LogLevel : Swift.Equatable {}
extension flutter_bluetooth.LogLevel : Swift.Hashable {}
extension flutter_bluetooth.LogLevel : Swift.RawRepresentable {}
